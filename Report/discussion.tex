\section{Discussion}
\label{sec:discussion}

Here goes the discussion on what choices we made for our implementation w.r.t 
all the choices we discussed in the previous section. We will go with global
algorithm like pagerank, on input graphs with uniform vertex and edge 
distribution to start with. We will go with synchronous model inspite of some
performance disadvantages as it makes programming easier and is widely used. 
Since the kind of paritioning (vertex centric, edge centric or graph centric) 
should not matter that much for very uniform graphs, we will start with the most 
popular one i.e., vertex centric model. Choosing uniform graphs should help 
alleviate the skewed straggler problems affecting the synchronous model as well.
We will go with static partitioning since page rank keeps all the vertices active
throughout the run. \\

Then we do a theoretical analysis on the kind of network performance we could 
get. Given nodes of CPU c, memory m and network n for an input graph g = (v, e)
what would a perfectly written distributed page rank program with above 
characteristics give us in terms of network performance? \\


Argue that while all of the design choices we discussed in background and in the 
first paragraph affects how balanced the resource usage of the run is going to be,
the thing that seems to matter significantly is how input graph is partitioned. For 
the purposes of this project, we will look at how partitioning choices will affect
the resource usage balance of a graph algorithm, particularly pagerank. More details
on the partitioning is provided in the following section.


Instead of implementing distributed page rank from scratch, we decided to pick a one 
of the many graph processing frameworks available in the wild. We pickled giraph
\cite{ApacheGiraph}
for these reasons: very much in use, open sourced, matches much of the design choices we 
picked in the first paragraph, seen many recent optimizations from facebook
\cite{GiraphAtFacebook}, easier to plug in the partitioners, and more?
Downside: takes too much time and tuning to setup, only allows vertex partitioning, and more?



